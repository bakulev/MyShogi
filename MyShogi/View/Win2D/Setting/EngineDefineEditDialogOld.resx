<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>This dialog is necessary to use an external thinking engine with this software.
It is for creating / editing an "engine configuration file" (engine_define.xml).
(Because it is an extra function for those who understand, we do not provide official support. Please be careful.)

■ How to use the external thinking engine with this software ("Shogi God YaneuraOu" / MyShogi)

1. The external thinking engine must support the USI protocol.
2. For those who understand the settings of the external thinking engine.

It has been confirmed that shogi software "Gikou", "Apery", etc. work normally.

■ Procedure

Create a folder in the engine folder that exists in the folder where this software is installed.
(If the installation destination is ProgramFiles, etc., you must have Windows administrator privileges.
You may not be able to create the folder. )

Example) engine / gikou

In that folder, the engine definition file (engine_define.xml) created this time and
Place the thinking engine body and so on.

Also, if banner.png is prepared as a banner image in that folder with a width of 512px x height of 160px.
It will be displayed when the engine is selected.

■ Explanation of each setting item in the engine definition file


■ Explanation of each setting item in the engine definition file

-Description Simple

Write a brief description of the engine in one line.
Displayed when the engine is selected.

-Detailed description of the engine (Description)

Write a detailed description of the engine in about 3 lines.
Displayed when the engine is selected.

-Banner File Name

Set the file name of the banner image displayed when the engine is selected.

Prepare a banner with 512px width x 160px height,
Place it in the same folder as the engine definition file (engine_define.xml).

Example) banner.png

-Engine display name (Display Name)

The display name of the engine. It will appear on the screen as the name of the thought engine.

Example) YaneuraOu2020

-Engine Executable File Name (EngineExeName)

The executable file name of the thought engine.

For example, if this value is set to "engine", an executable file with the following file name will be started according to the CPU of the execution environment.
     "engine_nosse.exe": 32bit version
     "engine_sse2.exe": 64-bit version sse2 compatible
     "engine_sse41.exe": 64-bit version sse4.1 compatible
     "engine_sse42.exe": 64-bit version sse4.2 compatible
     "engine_avx2.exe": 64-bit version avx2 compatible

-Target CPU (Supported Cpus)

This is the target CPU.

NoSSE: 32bit version (used to run the OS in a 32bit environment)
SSE2: 64-bit version SSE2 compatible (Used with an SSE2-compatible CPU in a 64-bit environment)
SSE4.1: 64-bit version SSE2 compatible (Used with a CPU that supports SSE4.1 in a 64-bit environment)
SSE4.2: 64bit version SSE2 compatible (OS is 64bit environment and used with SSE4.2 compatible CPU)
AVX2: 64-bit version SSE2 compatible (Used with an AVX2-compatible CPU in a 64-bit environment)

For example, if the operating environment only supports SSE4.2, execute the executable file for SSE4.2.
However, if the "SSE 4.2" checkbox in "Target CPU" is not checked,
Since the executable file for SSE4.2 is not prepared, it is a lower CPU.
Run the executable file for SSE4.1.
(Similarly below, if the SSE4.1 checkbox is not checked, SSE2 will be executed.
If the SSE2 checkbox is unchecked, run NoSSE. )

-Working Memory

Memory used for search (excluding USI_Hash) Unit is [MB]
Example) EvalHash (128MB) + USI for standby thread (25MB) + book reading (about 50MB) ≒ 200MB.
Larger joseki files require more memory than this.
It is better to set the value with a little margin.

-Memory for each thread (StackPerThread)

Memory size used per thread. The unit is [MB]
It is assumed that the number set in Threads x this value consumes extra physical memory.

-Memory for evaluation function (EvalMemory)

Memory for merit function. The unit is [MB]
If EvalShare is turned on for memory sharing, the second engine shall be deducted by this amount.

-MinimumHashMemory

Minimum memory for replacement table (USI_Hash). A line that doesn't work properly without this much. The unit is [MB]

* On the GUI side, if there is no free physical memory for RequiredMemory + MinimumHashMemory, a warning will be issued when the engine is selected.

-Display Order

Display order on the engine selection screen. This is supposed to be displayed in descending order.
Default 0. (Displayed at the very end)

// Reserve 10000-19999 for the commercial version.
// "Shogi God Yaneurao" (2018) uses 10000-10099.

・ Engine Type

"For normal game" (EngineType == 0): Normal search engine. (You can send a go command)
"For checkmate shogi" (EngineType == 1): Does it support checkmate shogi? (Send go mate command)
"Normal game + Tsume shogi)" (Engine Type == 2): Normal search + Tsume shogi compatible engine

In addition, special engines such as those for checkered shogi will be added here in the future.</value>
  </data>
  <metadata name="toolTip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="label16.ToolTip" xml:space="preserve">
    <value>・エンジン種別(EngineType)

「通常対局用」 (EngineType == 0) : 通常探索エンジン。(goコマンドが送れる)
「詰将棋用」    (EngineType == 1) : 詰み将棋に対応しているか。(go mateコマンドが送れる)
「通常対局＋詰将棋用)」(EngineType == 2) : 通常探索＋詰将棋対応のエンジン

その他、王手将棋用など、特殊なエンジンについても将来的にはここに追加していく予定。</value>
  </data>
  <data name="label7.ToolTip" xml:space="preserve">
    <value>・対象CPU(SupportedCpus)

動作対象のCPUです。

NoSSE : 32bit版(OSが32bit環境で動作させるのに使います)
SSE2  : 64bit版SSE2対応(OSが64bit環境でSSE2対応のCPUで使います)
SSE4.1: 64bit版SSE2対応(OSが64bit環境でSSE4.1対応のCPUで使います)
SSE4.2: 64bit版SSE2対応(OSが64bit環境でSSE4.2対応のCPUで使います)
AVX2  : 64bit版SSE2対応(OSが64bit環境でAVX2対応のCPUで使います)

例えば、動作環境がSSE4.2までしか対応していない場合、SSE4.2用の実行ファイルを実行します。
しかし、「対象CPU」の「SSE4.2」のチェックボックスにチェックが入っていない場合、
SSE4.2用の実行ファイルは用意されていないということなので、それより下位のCPUである
SSE4.1用の実行ファイルを実行します。
(以下同様に、SSE4.1のチェックボックスにチェックが入っていない場合、SSE2を実行します。
SSE2のチェックボックスにチェックが入っていない場合、NoSSEを実行します。)</value>
  </data>
  <data name="label6.ToolTip" xml:space="preserve">
    <value>・エンジン実行ファイル名(EngineExeName)

思考エンジンの実行ファイル名です。

例えばこの値を"engine"とした場合、実行環境のCPUに合わせて以下のファイル名の実行ファイルが起動されます。
     "engine_nosse.exe"  : 32bit版
     "engine_sse2.exe"   : 64bit版sse2対応
     "engine_sse41.exe"  : 64bit版sse4.1対応
     "engine_sse42.exe"  : 64bit版sse4.2対応
     "engine_avx2.exe"   : 64bit版avx2対応</value>
  </data>
</root>